<objdefs>
   <obj.normal id="note quantizer" uuid="250b756241853185b0296cc743d283658abbd7b6" sha="2eb19f6d2e7223f7ae71dee8e7a8c8566ba307a4">
      <sDescription>quantize note input to a scale</sDescription>
      <author>Mark Harris</author>
      <license>BSD</license>
      <helpPatch>note quantizer.axh</helpPatch>
      <inlets>
         <frac32.bipolar name="note" description="note number (-64..63)"/>
         <int32 name="tonic" description="tonic note number (0-11)"/>
         <int32 name="offset" description="note input offset (0-128)"/>
      </inlets>
      <outlets>
         <frac32.bipolar name="note" description="note number (-64..63)"/>
      </outlets>
      <displays/>
      <params>
         <bin12 name="b12" noLabel="true"/>
      </params>
      <attribs/>
      <code.declaration><![CDATA[    int32_t _scaleVal;
    int8_t  _scale[12];
    int8_t  _nscale;
    int32_t  _note;
    int32_t  _tonic;
    int32_t  _offset;
    int32_t  _out;]]></code.declaration>
      <code.init><![CDATA[   _note = 0;
    _scaleVal = 0;
    _nscale = 0;
    _tonic = 0;
    _offset = 0;
    for(int i=0;i<12;i++) {
        _scale[i] = 0;
    }]]></code.init>
      <code.krate><![CDATA[    if (_scaleVal != param_b12) {
        // calculate new scale parameters as they changed
        // optimize for evaluation
        int x=0;
        for(int i=0;i<12;i++) {
            if(param_b12 & (1 << i)) {
                _scale[x++] = i;
            }
        }
        _nscale = x;
    }
    if (_note != inlet_note || _offset != inlet_offset || _scaleVal != param_b12
        || _tonic != inlet_tonic) {
        _note = inlet_note;
        _tonic = inlet_tonic;
        _offset = inlet_offset;
        _scaleVal = param_b12;
        int mn = (inlet_note  >> 21) + 64 - _offset;
        int8_t oct = mn / _nscale;
        int8_t n = mn  % _nscale;
        _out = ((oct * 12 + _scale[n] + _tonic )  - 64 ) << 21;
    }
    outlet_note = _out;
]]></code.krate>
   </obj.normal>
</objdefs>